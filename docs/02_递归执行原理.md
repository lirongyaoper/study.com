# 第二章：递归执行原理

## 目录
- [调用栈概述](#调用栈概述)
- [递归的执行过程](#递归的执行过程)
- [栈帧详解](#栈帧详解)
- [递归的内存模型](#递归的内存模型)
- [递归深度和栈溢出](#递归深度和栈溢出)
- [尾递归优化](#尾递归优化)

---

## 调用栈概述

### 什么是调用栈？

调用栈（Call Stack）是程序执行时用来存储函数调用信息的数据结构。它遵循**后进先出（LIFO）**的原则。

想象一下叠盘子：
- 放盘子时，新盘子放在最上面
- 取盘子时，从最上面取
- 调用栈的工作方式完全相同

### 调用栈的基本操作

```php
// 示例：普通函数调用
function a() {
    echo "进入函数 a\n";
    b();
    echo "离开函数 a\n";
}

function b() {
    echo "进入函数 b\n";
    c();
    echo "离开函数 b\n";
}

function c() {
    echo "进入函数 c\n";
    echo "离开函数 c\n";
}

a(); // 开始执行
```

调用栈的变化：
```
步骤1: [a]           // a 入栈
步骤2: [a, b]        // b 入栈
步骤3: [a, b, c]     // c 入栈
步骤4: [a, b]        // c 执行完毕，出栈
步骤5: [a]           // b 执行完毕，出栈
步骤6: []            // a 执行完毕，出栈
```

## 递归的执行过程

### 递归调用的特殊性

递归函数的特殊之处在于它调用的是自己，但原理和普通函数调用完全相同。

```php
function countdown($n) {
    if ($n <= 0) {
        echo "结束\n";
        return;
    }
    echo "$n\n";
    countdown($n - 1);
}

countdown(3);
```

### 执行过程详解

让我们逐步跟踪 `countdown(3)` 的执行：

```
1. countdown(3) 被调用
   - 栈: [countdown(3)]
   - 打印: 3
   - 调用 countdown(2)

2. countdown(2) 被调用
   - 栈: [countdown(3), countdown(2)]
   - 打印: 2
   - 调用 countdown(1)

3. countdown(1) 被调用
   - 栈: [countdown(3), countdown(2), countdown(1)]
   - 打印: 1
   - 调用 countdown(0)

4. countdown(0) 被调用
   - 栈: [countdown(3), countdown(2), countdown(1), countdown(0)]
   - 打印: 结束
   - 返回（基础情况）

5. 开始回溯
   - countdown(0) 结束，栈: [countdown(3), countdown(2), countdown(1)]
   - countdown(1) 结束，栈: [countdown(3), countdown(2)]
   - countdown(2) 结束，栈: [countdown(3)]
   - countdown(3) 结束，栈: []
```

### 可视化代码示例

```php
<?php
// 递归执行过程可视化
function visualizeRecursion($n, $depth = 0) {
    $indent = str_repeat("  ", $depth);
    
    echo $indent . "→ 进入 visualizeRecursion($n)\n";
    echo $indent . "  当前递归深度: $depth\n";
    
    if ($n <= 0) {
        echo $indent . "  到达基础情况\n";
        echo $indent . "← 返回 visualizeRecursion($n)\n";
        return;
    }
    
    echo $indent . "  准备递归调用...\n";
    visualizeRecursion($n - 1, $depth + 1);
    echo $indent . "← 返回 visualizeRecursion($n)\n";
}

// 运行示例
visualizeRecursion(3);
```

## 栈帧详解

### 什么是栈帧？

栈帧（Stack Frame）是调用栈中的一个单元，每次函数调用都会创建一个新的栈帧。

栈帧包含：
1. **局部变量**：函数内定义的变量
2. **参数**：传递给函数的参数
3. **返回地址**：函数执行完后返回的位置
4. **其他信息**：如寄存器状态等

### 递归中的栈帧

```php
function factorial($n) {
    // 每次调用都有自己的 $n
    if ($n <= 1) {
        return 1;
    }
    return $n * factorial($n - 1);
}
```

调用 `factorial(4)` 时的栈帧：

```
栈帧4: factorial(4) { $n = 4, 返回地址 = main }
栈帧3: factorial(3) { $n = 3, 返回地址 = factorial(4) }
栈帧2: factorial(2) { $n = 2, 返回地址 = factorial(3) }
栈帧1: factorial(1) { $n = 1, 返回地址 = factorial(2) }
```

## 递归的内存模型

### 内存使用分析

```php
<?php
// 监控递归的内存使用
function memoryMonitor($n, $depth = 0) {
    $memory_before = memory_get_usage();
    
    echo str_repeat("  ", $depth);
    echo "深度 $depth: 当前内存 " . number_format($memory_before) . " bytes\n";
    
    if ($n <= 0) {
        return 0;
    }
    
    // 创建一些局部变量来占用内存
    $local_array = range(1, 100);
    $result = $n + memoryMonitor($n - 1, $depth + 1);
    
    return $result;
}

echo "=== 递归内存使用监控 ===\n";
$initial_memory = memory_get_usage();
echo "初始内存: " . number_format($initial_memory) . " bytes\n\n";

memoryMonitor(10);

$final_memory = memory_get_usage();
echo "\n最终内存: " . number_format($final_memory) . " bytes\n";
echo "内存增长: " . number_format($final_memory - $initial_memory) . " bytes\n";
```

### 内存泄漏风险

递归不当可能导致：
1. **栈溢出**：递归太深
2. **内存耗尽**：每层递归创建大量数据
3. **性能下降**：频繁的函数调用开销

## 递归深度和栈溢出

### 栈溢出演示

```php
<?php
// 危险：这会导致栈溢出
function infiniteRecursion($n) {
    echo "递归深度: $n\n";
    infiniteRecursion($n + 1); // 没有基础情况！
}

// 测试最大递归深度
function testMaxDepth($n = 0) {
    try {
        testMaxDepth($n + 1);
    } catch (Error $e) {
        echo "最大递归深度约为: $n\n";
        echo "错误信息: " . $e->getMessage() . "\n";
    }
}

// 安全的深度测试
function safeDepthTest($target, $current = 0) {
    if ($current >= $target) {
        echo "成功达到深度: $current\n";
        return $current;
    }
    
    // 每100层报告一次
    if ($current % 100 == 0 && $current > 0) {
        echo "当前深度: $current\n";
    }
    
    return safeDepthTest($target, $current + 1);
}

echo "=== 递归深度测试 ===\n";
echo "测试深度 1000:\n";
safeDepthTest(1000);

echo "\n注意：PHP 默认的最大递归深度通常在 100-1000 之间\n";
echo "可以通过 xdebug.max_nesting_level 配置调整\n";
```

### 如何避免栈溢出

1. **确保有正确的基础情况**
2. **限制递归深度**
3. **使用迭代替代深度递归**
4. **考虑尾递归优化**

## 尾递归优化

### 什么是尾递归？

尾递归是指递归调用是函数的最后一个操作。

```php
// 普通递归
function factorial_normal($n) {
    if ($n <= 1) return 1;
    return $n * factorial_normal($n - 1); // 递归后还要乘法
}

// 尾递归
function factorial_tail($n, $accumulator = 1) {
    if ($n <= 1) return $accumulator;
    return factorial_tail($n - 1, $n * $accumulator); // 递归是最后操作
}
```

### 尾递归的优势

理论上，尾递归可以被优化成循环，避免栈的增长。但要注意：
- **PHP 不支持尾递归优化**
- 即使是尾递归形式，PHP 仍会创建新的栈帧

### 手动优化示例

```php
// 将尾递归转换为循环
function factorial_optimized($n) {
    $accumulator = 1;
    while ($n > 1) {
        $accumulator *= $n;
        $n--;
    }
    return $accumulator;
}
```

## 实践练习

### 练习1：栈追踪器

```php
<?php
class StackTracer {
    private static $stack = [];
    
    public static function push($function, $params) {
        self::$stack[] = "$function(" . implode(", ", $params) . ")";
        self::display();
    }
    
    public static function pop() {
        array_pop(self::$stack);
        self::display();
    }
    
    public static function display() {
        echo "调用栈: [" . implode(" → ", self::$stack) . "]\n";
    }
}

function tracedFactorial($n) {
    StackTracer::push("factorial", [$n]);
    
    if ($n <= 1) {
        $result = 1;
    } else {
        $result = $n * tracedFactorial($n - 1);
    }
    
    StackTracer::pop();
    return $result;
}

echo "=== 调用栈追踪 ===\n";
$result = tracedFactorial(4);
echo "结果: $result\n";
```

## 小结

1. **调用栈**：存储函数调用信息的 LIFO 结构
2. **栈帧**：包含局部变量、参数和返回地址
3. **递归过程**：不断入栈，到达基础情况后出栈
4. **栈溢出**：递归太深导致栈空间耗尽
5. **优化考虑**：PHP 不支持尾递归优化，需要手动优化

## 思考题

1. 为什么递归函数的每次调用都有独立的局部变量？
2. 如何计算一个递归函数的空间复杂度？
3. 什么情况下递归比循环更消耗内存？

## 下一步

理解了递归的执行原理后，下一章我们将学习[递归模式详解](03_递归模式详解.md)，探索不同类型的递归模式和应用场景。
