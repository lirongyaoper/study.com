# 第四章：递归优化技巧

## 目录
- [记忆化（Memoization）](#记忆化memoization)
- [动态规划](#动态规划)
- [尾递归优化](#尾递归优化)
- [迭代替代](#迭代替代)
- [剪枝优化](#剪枝优化)
- [分治优化](#分治优化)
- [空间优化](#空间优化)
- [并行化](#并行化)

---

## 记忆化（Memoization）

### 原理
记忆化是一种优化技术，通过缓存已计算的结果来避免重复计算。

### 基本实现
```php
class Memoizer {
    private $cache = [];
    private $func;
    
    public function __construct($func) {
        $this->func = $func;
    }
    
    public function call(...$args) {
        $key = serialize($args);
        
        if (!isset($this->cache[$key])) {
            $this->cache[$key] = call_user_func_array($this->func, $args);
        }
        
        return $this->cache[$key];
    }
    
    public function clearCache() {
        $this->cache = [];
    }
    
    public function getCacheSize() {
        return count($this->cache);
    }
}

// 使用示例
$fibMemo = new Memoizer(function($n) use (&$fibMemo) {
    if ($n <= 1) return $n;
    return $fibMemo->call($n - 1) + $fibMemo->call($n - 2);
});

echo $fibMemo->call(40); // 快速计算
```

### 手动记忆化示例
```php
// 斐波那契数列记忆化
function fibonacci_memo($n, &$memo = []) {
    // 检查缓存
    if (isset($memo[$n])) {
        return $memo[$n];
    }
    
    // 基础情况
    if ($n <= 1) {
        return $n;
    }
    
    // 计算并缓存
    $memo[$n] = fibonacci_memo($n - 1, $memo) + fibonacci_memo($n - 2, $memo);
    
    return $memo[$n];
}

// 最长公共子序列记忆化
function lcs_memo($str1, $str2, $i = null, $j = null, &$memo = []) {
    if ($i === null) $i = strlen($str1) - 1;
    if ($j === null) $j = strlen($str2) - 1;
    
    // 生成缓存键
    $key = "$i,$j";
    if (isset($memo[$key])) {
        return $memo[$key];
    }
    
    // 基础情况
    if ($i < 0 || $j < 0) {
        return 0;
    }
    
    // 递归计算
    if ($str1[$i] === $str2[$j]) {
        $memo[$key] = 1 + lcs_memo($str1, $str2, $i - 1, $j - 1, $memo);
    } else {
        $memo[$key] = max(
            lcs_memo($str1, $str2, $i - 1, $j, $memo),
            lcs_memo($str1, $str2, $i, $j - 1, $memo)
        );
    }
    
    return $memo[$key];
}
```

### 适用场景
- 有重叠子问题的递归
- 纯函数（相同输入总是产生相同输出）
- 计算成本高的递归函数

## 动态规划

### 原理
动态规划是自底向上解决问题，避免递归调用栈。

### 递归到动态规划的转换
```php
// 递归版本（自顶向下）
function fib_recursive($n) {
    if ($n <= 1) return $n;
    return fib_recursive($n - 1) + fib_recursive($n - 2);
}

// 动态规划版本（自底向上）
function fib_dp($n) {
    if ($n <= 1) return $n;
    
    $dp = array_fill(0, $n + 1, 0);
    $dp[0] = 0;
    $dp[1] = 1;
    
    for ($i = 2; $i <= $n; $i++) {
        $dp[$i] = $dp[$i - 1] + $dp[$i - 2];
    }
    
    return $dp[$n];
}

// 空间优化的动态规划
function fib_dp_optimized($n) {
    if ($n <= 1) return $n;
    
    $prev = 0;
    $curr = 1;
    
    for ($i = 2; $i <= $n; $i++) {
        $next = $prev + $curr;
        $prev = $curr;
        $curr = $next;
    }
    
    return $curr;
}
```

### 经典动态规划问题
```php
// 背包问题
function knapsack($weights, $values, $capacity) {
    $n = count($weights);
    $dp = array_fill(0, $n + 1, array_fill(0, $capacity + 1, 0));
    
    for ($i = 1; $i <= $n; $i++) {
        for ($w = 0; $w <= $capacity; $w++) {
            // 不选择当前物品
            $dp[$i][$w] = $dp[$i - 1][$w];
            
            // 选择当前物品（如果可以）
            if ($weights[$i - 1] <= $w) {
                $dp[$i][$w] = max(
                    $dp[$i][$w],
                    $values[$i - 1] + $dp[$i - 1][$w - $weights[$i - 1]]
                );
            }
        }
    }
    
    return $dp[$n][$capacity];
}

// 最长递增子序列
function longestIncreasingSubsequence($arr) {
    $n = count($arr);
    if ($n === 0) return 0;
    
    $dp = array_fill(0, $n, 1);
    
    for ($i = 1; $i < $n; $i++) {
        for ($j = 0; $j < $i; $j++) {
            if ($arr[$j] < $arr[$i]) {
                $dp[$i] = max($dp[$i], $dp[$j] + 1);
            }
        }
    }
    
    return max($dp);
}
```

## 尾递归优化

### 转换为尾递归
```php
// 普通递归
function sum_normal($n) {
    if ($n <= 0) return 0;
    return $n + sum_normal($n - 1);
}

// 尾递归版本
function sum_tail($n, $acc = 0) {
    if ($n <= 0) return $acc;
    return sum_tail($n - 1, $acc + $n);
}

// 尾递归阶乘
function factorial_tail($n, $acc = 1) {
    if ($n <= 1) return $acc;
    return factorial_tail($n - 1, $n * $acc);
}

// 尾递归反转列表
function reverse_tail($arr, $acc = []) {
    if (empty($arr)) return $acc;
    
    $first = array_shift($arr);
    array_unshift($acc, $first);
    
    return reverse_tail($arr, $acc);
}
```

### 手动优化为循环
```php
// 将尾递归转换为循环
function factorial_loop($n) {
    $acc = 1;
    
    while ($n > 1) {
        $acc *= $n;
        $n--;
    }
    
    return $acc;
}

// 通用的尾递归转循环模式
class TailRecursionOptimizer {
    public static function optimize($initialArgs, $condition, $nextArgs, $getResult) {
        $args = $initialArgs;
        
        while (!call_user_func($condition, ...$args)) {
            $args = call_user_func($nextArgs, ...$args);
        }
        
        return call_user_func($getResult, ...$args);
    }
}

// 使用示例
$factorial = function($n) {
    return TailRecursionOptimizer::optimize(
        [$n, 1], // 初始参数
        fn($n, $acc) => $n <= 1, // 终止条件
        fn($n, $acc) => [$n - 1, $n * $acc], // 下一次迭代的参数
        fn($n, $acc) => $acc // 获取结果
    );
};
```

## 迭代替代

### 使用栈模拟递归
```php
// 递归遍历二叉树
function inorderRecursive($root) {
    if ($root === null) return [];
    
    $result = [];
    $result = array_merge($result, inorderRecursive($root->left));
    $result[] = $root->value;
    $result = array_merge($result, inorderRecursive($root->right));
    
    return $result;
}

// 迭代版本
function inorderIterative($root) {
    $result = [];
    $stack = [];
    $current = $root;
    
    while ($current !== null || !empty($stack)) {
        // 走到最左边
        while ($current !== null) {
            $stack[] = $current;
            $current = $current->left;
        }
        
        // 处理节点
        $current = array_pop($stack);
        $result[] = $current->value;
        
        // 转向右子树
        $current = $current->right;
    }
    
    return $result;
}

// 使用队列进行层序遍历
function levelOrder($root) {
    if ($root === null) return [];
    
    $result = [];
    $queue = [$root];
    
    while (!empty($queue)) {
        $level = [];
        $levelSize = count($queue);
        
        for ($i = 0; $i < $levelSize; $i++) {
            $node = array_shift($queue);
            $level[] = $node->value;
            
            if ($node->left !== null) {
                $queue[] = $node->left;
            }
            if ($node->right !== null) {
                $queue[] = $node->right;
            }
        }
        
        $result[] = $level;
    }
    
    return $result;
}
```

## 剪枝优化

### 基本剪枝
```php
// N皇后问题的剪枝
class NQueensOptimized {
    private $solutions = [];
    private $n;
    
    public function solve($n) {
        $this->n = $n;
        $this->solutions = [];
        
        // 使用一维数组表示棋盘
        $board = array_fill(0, $n, -1);
        
        // 使用集合快速检查冲突
        $cols = [];
        $diag1 = [];
        $diag2 = [];
        
        $this->placeQueens($board, 0, $cols, $diag1, $diag2);
        
        return $this->solutions;
    }
    
    private function placeQueens($board, $row, &$cols, &$diag1, &$diag2) {
        if ($row === $this->n) {
            $this->solutions[] = array_slice($board, 0);
            return;
        }
        
        for ($col = 0; $col < $this->n; $col++) {
            // 剪枝：快速检查冲突
            if (isset($cols[$col]) || 
                isset($diag1[$row - $col]) || 
                isset($diag2[$row + $col])) {
                continue;
            }
            
            // 放置皇后
            $board[$row] = $col;
            $cols[$col] = true;
            $diag1[$row - $col] = true;
            $diag2[$row + $col] = true;
            
            // 递归下一行
            $this->placeQueens($board, $row + 1, $cols, $diag1, $diag2);
            
            // 回溯
            unset($cols[$col]);
            unset($diag1[$row - $col]);
            unset($diag2[$row + $col]);
        }
    }
}

// 数独求解的剪枝
class SudokuOptimized {
    private $board;
    private $rows = [];
    private $cols = [];
    private $boxes = [];
    
    public function solve($board) {
        $this->board = $board;
        $this->initConstraints();
        
        if ($this->backtrack()) {
            return $this->board;
        }
        
        return null;
    }
    
    private function initConstraints() {
        // 初始化约束集合
        for ($i = 0; $i < 9; $i++) {
            $this->rows[$i] = [];
            $this->cols[$i] = [];
            $this->boxes[$i] = [];
        }
        
        // 记录已有数字
        for ($i = 0; $i < 9; $i++) {
            for ($j = 0; $j < 9; $j++) {
                if ($this->board[$i][$j] !== 0) {
                    $num = $this->board[$i][$j];
                    $boxIndex = floor($i / 3) * 3 + floor($j / 3);
                    
                    $this->rows[$i][$num] = true;
                    $this->cols[$j][$num] = true;
                    $this->boxes[$boxIndex][$num] = true;
                }
            }
        }
    }
    
    private function backtrack() {
        // 找到空格
        $empty = $this->findEmpty();
        if ($empty === null) {
            return true;
        }
        
        list($row, $col) = $empty;
        $boxIndex = floor($row / 3) * 3 + floor($col / 3);
        
        // 尝试数字1-9
        for ($num = 1; $num <= 9; $num++) {
            // 剪枝：快速检查
            if (isset($this->rows[$row][$num]) ||
                isset($this->cols[$col][$num]) ||
                isset($this->boxes[$boxIndex][$num])) {
                continue;
            }
            
            // 放置数字
            $this->board[$row][$col] = $num;
            $this->rows[$row][$num] = true;
            $this->cols[$col][$num] = true;
            $this->boxes[$boxIndex][$num] = true;
            
            // 递归
            if ($this->backtrack()) {
                return true;
            }
            
            // 回溯
            $this->board[$row][$col] = 0;
            unset($this->rows[$row][$num]);
            unset($this->cols[$col][$num]);
            unset($this->boxes[$boxIndex][$num]);
        }
        
        return false;
    }
    
    private function findEmpty() {
        // 启发式：选择候选数字最少的空格
        $minCandidates = 10;
        $bestCell = null;
        
        for ($i = 0; $i < 9; $i++) {
            for ($j = 0; $j < 9; $j++) {
                if ($this->board[$i][$j] === 0) {
                    $candidates = $this->countCandidates($i, $j);
                    if ($candidates < $minCandidates) {
                        $minCandidates = $candidates;
                        $bestCell = [$i, $j];
                    }
                }
            }
        }
        
        return $bestCell;
    }
    
    private function countCandidates($row, $col) {
        $boxIndex = floor($row / 3) * 3 + floor($col / 3);
        $count = 0;
        
        for ($num = 1; $num <= 9; $num++) {
            if (!isset($this->rows[$row][$num]) &&
                !isset($this->cols[$col][$num]) &&
                !isset($this->boxes[$boxIndex][$num])) {
                $count++;
            }
        }
        
        return $count;
    }
}
```

## 分治优化

### 优化分治算法
```php
// 优化的归并排序
class MergeSortOptimized {
    // 使用插入排序处理小数组
    private static function insertionSort(&$arr, $left, $right) {
        for ($i = $left + 1; $i <= $right; $i++) {
            $key = $arr[$i];
            $j = $i - 1;
            
            while ($j >= $left && $arr[$j] > $key) {
                $arr[$j + 1] = $arr[$j];
                $j--;
            }
            
            $arr[$j + 1] = $key;
        }
    }
    
    public static function sort(&$arr, $left = 0, $right = null) {
        if ($right === null) {
            $right = count($arr) - 1;
        }
        
        // 小数组使用插入排序
        if ($right - $left < 10) {
            self::insertionSort($arr, $left, $right);
            return;
        }
        
        $mid = floor(($left + $right) / 2);
        
        // 递归排序
        self::sort($arr, $left, $mid);
        self::sort($arr, $mid + 1, $right);
        
        // 如果已经有序，跳过合并
        if ($arr[$mid] <= $arr[$mid + 1]) {
            return;
        }
        
        // 合并
        self::merge($arr, $left, $mid, $right);
    }
    
    private static function merge(&$arr, $left, $mid, $right) {
        $temp = [];
        $i = $left;
        $j = $mid + 1;
        
        while ($i <= $mid && $j <= $right) {
            if ($arr[$i] <= $arr[$j]) {
                $temp[] = $arr[$i++];
            } else {
                $temp[] = $arr[$j++];
            }
        }
        
        while ($i <= $mid) {
            $temp[] = $arr[$i++];
        }
        
        while ($j <= $right) {
            $temp[] = $arr[$j++];
        }
        
        for ($i = 0; $i < count($temp); $i++) {
            $arr[$left + $i] = $temp[$i];
        }
    }
}

// 快速幂算法
function power($base, $exp) {
    if ($exp === 0) return 1;
    
    if ($exp % 2 === 0) {
        $half = power($base, $exp / 2);
        return $half * $half;
    } else {
        return $base * power($base, $exp - 1);
    }
}

// 矩阵快速幂（用于优化斐波那契）
function matrixMultiply($a, $b) {
    return [
        [$a[0][0] * $b[0][0] + $a[0][1] * $b[1][0], 
         $a[0][0] * $b[0][1] + $a[0][1] * $b[1][1]],
        [$a[1][0] * $b[0][0] + $a[1][1] * $b[1][0], 
         $a[1][0] * $b[0][1] + $a[1][1] * $b[1][1]]
    ];
}

function matrixPower($matrix, $n) {
    if ($n === 1) return $matrix;
    
    if ($n % 2 === 0) {
        $half = matrixPower($matrix, $n / 2);
        return matrixMultiply($half, $half);
    } else {
        return matrixMultiply($matrix, matrixPower($matrix, $n - 1));
    }
}

function fibonacciMatrix($n) {
    if ($n <= 1) return $n;
    
    $matrix = [[1, 1], [1, 0]];
    $result = matrixPower($matrix, $n);
    
    return $result[0][1];
}
```

## 空间优化

### 减少空间使用
```php
// 使用位运算优化空间
class SpaceOptimizedNQueens {
    private $count = 0;
    
    public function totalNQueens($n) {
        $this->count = 0;
        $this->solve(0, 0, 0, 0, $n);
        return $this->count;
    }
    
    private function solve($row, $cols, $diag1, $diag2, $n) {
        if ($row === $n) {
            $this->count++;
            return;
        }
        
        $availablePositions = ((1 << $n) - 1) & ~($cols | $diag1 | $diag2);
        
        while ($availablePositions !== 0) {
            $position = $availablePositions & -$availablePositions;
            $availablePositions -= $position;
            
            $this->solve(
                $row + 1,
                $cols | $position,
                ($diag1 | $position) << 1,
                ($diag2 | $position) >> 1,
                $n
            );
        }
    }
}

// 滚动数组优化
function editDistance($str1, $str2) {
    $m = strlen($str1);
    $n = strlen($str2);
    
    // 只需要两行而不是整个矩阵
    $prev = array_fill(0, $n + 1, 0);
    $curr = array_fill(0, $n + 1, 0);
    
    // 初始化第一行
    for ($j = 0; $j <= $n; $j++) {
        $prev[$j] = $j;
    }
    
    for ($i = 1; $i <= $m; $i++) {
        $curr[0] = $i;
        
        for ($j = 1; $j <= $n; $j++) {
            if ($str1[$i - 1] === $str2[$j - 1]) {
                $curr[$j] = $prev[$j - 1];
            } else {
                $curr[$j] = 1 + min(
                    $prev[$j],     // 删除
                    $curr[$j - 1], // 插入
                    $prev[$j - 1]  // 替换
                );
            }
        }
        
        // 交换数组
        $temp = $prev;
        $prev = $curr;
        $curr = $temp;
    }
    
    return $prev[$n];
}
```

## 并行化

### 分治并行
```php
// 使用多进程进行并行计算（PHP示例）
class ParallelMergeSort {
    public static function sort($arr) {
        $n = count($arr);
        if ($n <= 1) return $arr;
        
        // 对于大数组，使用并行处理
        if ($n > 10000 && function_exists('pcntl_fork')) {
            return self::parallelSort($arr);
        }
        
        // 否则使用普通归并排序
        $mid = floor($n / 2);
        $left = array_slice($arr, 0, $mid);
        $right = array_slice($arr, $mid);
        
        return self::merge(self::sort($left), self::sort($right));
    }
    
    private static function parallelSort($arr) {
        $mid = floor(count($arr) / 2);
        $left = array_slice($arr, 0, $mid);
        $right = array_slice($arr, $mid);
        
        $pid = pcntl_fork();
        
        if ($pid === -1) {
            // Fork失败，使用普通排序
            return self::merge(self::sort($left), self::sort($right));
        } elseif ($pid === 0) {
            // 子进程：排序左半部分
            $sorted = self::sort($left);
            // 将结果写入共享内存或文件
            file_put_contents('/tmp/sort_left', serialize($sorted));
            exit(0);
        } else {
            // 父进程：排序右半部分
            $sortedRight = self::sort($right);
            
            // 等待子进程完成
            pcntl_waitpid($pid, $status);
            
            // 读取左半部分结果
            $sortedLeft = unserialize(file_get_contents('/tmp/sort_left'));
            unlink('/tmp/sort_left');
            
            return self::merge($sortedLeft, $sortedRight);
        }
    }
    
    private static function merge($left, $right) {
        $result = [];
        $i = $j = 0;
        
        while ($i < count($left) && $j < count($right)) {
            if ($left[$i] <= $right[$j]) {
                $result[] = $left[$i++];
            } else {
                $result[] = $right[$j++];
            }
        }
        
        while ($i < count($left)) {
            $result[] = $left[$i++];
        }
        
        while ($j < count($right)) {
            $result[] = $right[$j++];
        }
        
        return $result;
    }
}
```

## 优化技巧总结

### 1. 选择合适的优化策略

| 问题特征 | 推荐优化 | 示例 |
|---------|---------|------|
| 重复计算多 | 记忆化 | 斐波那契、动态规划 |
| 可以自底向上 | 转为迭代 | 大部分尾递归 |
| 搜索空间大 | 剪枝 | 回溯算法 |
| 问题规模大 | 分治+并行 | 排序、矩阵运算 |
| 空间限制 | 滚动数组 | 动态规划 |

### 2. 性能测试框架
```php
class RecursionBenchmark {
    public static function compare($functions, $input, $iterations = 100) {
        $results = [];
        
        foreach ($functions as $name => $func) {
            $totalTime = 0;
            $totalMemory = 0;
            
            for ($i = 0; $i < $iterations; $i++) {
                $startMemory = memory_get_usage();
                $startTime = microtime(true);
                
                $result = $func($input);
                
                $totalTime += microtime(true) - $startTime;
                $totalMemory += memory_get_peak_usage() - $startMemory;
            }
            
            $results[$name] = [
                'avg_time' => $totalTime / $iterations,
                'avg_memory' => $totalMemory / $iterations,
                'result' => $result
            ];
        }
        
        return $results;
    }
    
    public static function printResults($results) {
        echo "性能比较结果：\n";
        echo str_pad("方法", 20) . str_pad("平均时间(ms)", 15) . 
             str_pad("平均内存(KB)", 15) . "\n";
        echo str_repeat("-", 50) . "\n";
        
        foreach ($results as $name => $data) {
            echo str_pad($name, 20) . 
                 str_pad(number_format($data['avg_time'] * 1000, 4), 15) .
                 str_pad(number_format($data['avg_memory'] / 1024, 2), 15) . "\n";
        }
    }
}

// 使用示例
$functions = [
    '普通递归' => function($n) {
        return fibonacci($n);
    },
    '记忆化' => function($n) {
        $memo = [];
        return fibonacci_memo($n, $memo);
    },
    '动态规划' => function($n) {
        return fib_dp($n);
    },
    '矩阵快速幂' => function($n) {
        return fibonacciMatrix($n);
    }
];

$results = RecursionBenchmark::compare($functions, 30, 10);
RecursionBenchmark::printResults($results);
```

## 小结

1. **记忆化**：适用于有重复计算的递归
2. **动态规划**：自底向上，避免递归调用
3. **尾递归优化**：转换为迭代，减少栈使用
4. **剪枝**：减少搜索空间，提高效率
5. **分治优化**：利用问题特性，减少计算量
6. **空间优化**：使用位运算、滚动数组等技巧
7. **并行化**：利用多核处理器加速计算

选择合适的优化技巧需要：
- 分析问题特征
- 理解性能瓶颈
- 权衡时间和空间
- 考虑代码可读性

记住：过早优化是万恶之源。先确保代码正确，再考虑优化。

## 思考题

1. 什么情况下记忆化比动态规划更合适？
2. 如何判断一个递归算法是否适合并行化？
3. 剪枝和记忆化可以同时使用吗？有什么注意事项？
