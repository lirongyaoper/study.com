# 第三章：递归模式详解

## 目录
- [线性递归](#线性递归)
- [尾递归](#尾递归)
- [二分递归](#二分递归)
- [多路递归](#多路递归)
- [相互递归](#相互递归)
- [嵌套递归](#嵌套递归)
- [递归模式选择指南](#递归模式选择指南)

---

## 线性递归

### 定义
线性递归是最简单的递归形式，每个递归函数最多只调用自己一次。

### 特征
- 每层只有一次递归调用
- 递归深度与问题规模成正比
- 通常容易转换为循环

### 示例：阶乘计算
```php
function factorial($n) {
    if ($n <= 1) return 1;
    return $n * factorial($n - 1);  // 只有一次递归调用
}
```

### 执行轨迹
```
factorial(5)
  → 5 * factorial(4)
    → 4 * factorial(3)
      → 3 * factorial(2)
        → 2 * factorial(1)
          → 1
        ← 2
      ← 6
    ← 24
  ← 120
```

### 优缺点
**优点**：
- 简单直观
- 易于理解和实现
- 内存使用可预测

**缺点**：
- 可能导致栈溢出
- 某些情况下效率不高

## 尾递归

### 定义
尾递归是线性递归的特殊形式，递归调用是函数的最后一个操作。

### 特征
- 递归调用后没有其他操作
- 理论上可以优化为循环
- 不需要保存中间状态

### 示例：尾递归阶乘
```php
function factorial_tail($n, $accumulator = 1) {
    if ($n <= 1) return $accumulator;
    return factorial_tail($n - 1, $n * $accumulator);  // 尾递归
}
```

### 对比普通递归
```php
// 普通递归（需要保存中间状态）
return $n * factorial($n - 1);  // 还要执行乘法

// 尾递归（不需要保存状态）
return factorial_tail($n - 1, $n * $accumulator);  // 直接返回
```

### 手动优化为循环
```php
function factorial_loop($n) {
    $accumulator = 1;
    while ($n > 1) {
        $accumulator *= $n;
        $n--;
    }
    return $accumulator;
}
```

### 应用场景
- 累加/累乘运算
- 状态机实现
- 某些搜索算法

## 二分递归

### 定义
二分递归（二叉递归）中，每个函数调用会产生两次递归调用。

### 特征
- 每层有两次递归调用
- 形成二叉树结构
- 时间复杂度通常是指数级

### 示例：斐波那契数列
```php
function fibonacci($n) {
    if ($n <= 1) return $n;
    return fibonacci($n - 1) + fibonacci($n - 2);  // 两次递归调用
}
```

### 递归树
```
                    fib(5)
                   /      \
              fib(4)       fib(3)
             /     \       /     \
        fib(3)    fib(2) fib(2)  fib(1)
        /    \    /    \  /    \
    fib(2) fib(1) fib(1) fib(0) ...
```

### 优化技巧

#### 1. 记忆化（Memoization）
```php
function fibonacci_memo($n, &$cache = []) {
    if (isset($cache[$n])) return $cache[$n];
    
    if ($n <= 1) return $n;
    
    $cache[$n] = fibonacci_memo($n - 1, $cache) + 
                 fibonacci_memo($n - 2, $cache);
    return $cache[$n];
}
```

#### 2. 自底向上
```php
function fibonacci_bottom_up($n) {
    if ($n <= 1) return $n;
    
    $prev = 0;
    $curr = 1;
    
    for ($i = 2; $i <= $n; $i++) {
        $next = $prev + $curr;
        $prev = $curr;
        $curr = $next;
    }
    
    return $curr;
}
```

### 应用场景
- 分治算法（快速排序、归并排序）
- 树的遍历
- 组合问题

## 多路递归

### 定义
多路递归中，每个函数调用可能产生多次（超过两次）递归调用。

### 特征
- 每层有多次递归调用
- 形成多叉树结构
- 复杂度可能非常高

### 示例：生成所有排列
```php
function permutations($arr, $start = 0, &$result = []) {
    if ($start >= count($arr)) {
        $result[] = array_slice($arr, 0);
        return;
    }
    
    for ($i = $start; $i < count($arr); $i++) {
        // 交换
        $temp = $arr[$start];
        $arr[$start] = $arr[$i];
        $arr[$i] = $temp;
        
        // 递归生成剩余部分的排列
        permutations($arr, $start + 1, $result);
        
        // 回溯：恢复原始顺序
        $temp = $arr[$start];
        $arr[$start] = $arr[$i];
        $arr[$i] = $temp;
    }
}
```

### 示例：子集生成
```php
function subsets($nums, $index = 0, $current = [], &$result = []) {
    if ($index >= count($nums)) {
        $result[] = $current;
        return;
    }
    
    // 不包含当前元素
    subsets($nums, $index + 1, $current, $result);
    
    // 包含当前元素
    $current[] = $nums[$index];
    subsets($nums, $index + 1, $current, $result);
}
```

### 应用场景
- 回溯算法
- 搜索问题
- 组合优化

## 相互递归

### 定义
两个或多个函数相互调用，形成递归关系。

### 特征
- 函数A调用函数B，函数B调用函数A
- 需要多个基础情况
- 常见于状态机实现

### 示例：奇偶判断
```php
function isEven($n) {
    if ($n === 0) return true;
    if ($n === 1) return false;
    return isOdd($n - 1);
}

function isOdd($n) {
    if ($n === 0) return false;
    if ($n === 1) return true;
    return isEven($n - 1);
}
```

### 示例：简单表达式解析
```php
class ExpressionParser {
    private $tokens;
    private $position;
    
    // 解析加减法
    public function parseExpression() {
        $left = $this->parseTerm();
        
        while ($this->currentToken() === '+' || $this->currentToken() === '-') {
            $op = $this->currentToken();
            $this->advance();
            $right = $this->parseTerm();
            $left = $op === '+' ? $left + $right : $left - $right;
        }
        
        return $left;
    }
    
    // 解析乘除法
    private function parseTerm() {
        $left = $this->parseFactor();
        
        while ($this->currentToken() === '*' || $this->currentToken() === '/') {
            $op = $this->currentToken();
            $this->advance();
            $right = $this->parseFactor();
            $left = $op === '*' ? $left * $right : $left / $right;
        }
        
        return $left;
    }
    
    // 解析数字或括号表达式
    private function parseFactor() {
        if ($this->currentToken() === '(') {
            $this->advance(); // 跳过 '('
            $result = $this->parseExpression(); // 相互递归
            $this->advance(); // 跳过 ')'
            return $result;
        }
        
        $num = intval($this->currentToken());
        $this->advance();
        return $num;
    }
    
    // 辅助方法
    private function currentToken() {
        return $this->position < count($this->tokens) ? 
               $this->tokens[$this->position] : null;
    }
    
    private function advance() {
        $this->position++;
    }
}
```

### 应用场景
- 编译器/解释器
- 状态机
- 游戏AI

## 嵌套递归

### 定义
递归函数的参数本身也是递归调用的结果。

### 特征
- 递归调用作为另一个递归调用的参数
- 增长速度极快
- 很难优化

### 示例：Ackermann函数
```php
function ackermann($m, $n) {
    if ($m === 0) {
        return $n + 1;
    }
    if ($n === 0) {
        return ackermann($m - 1, 1);
    }
    return ackermann($m - 1, ackermann($m, $n - 1));  // 嵌套递归
}
```

### 增长速度示例
```
ackermann(0, n) = n + 1
ackermann(1, n) = n + 2
ackermann(2, n) = 2n + 3
ackermann(3, n) = 2^(n+3) - 3
ackermann(4, n) = 2^2^...^2 (n+3个2) - 3
```

### 注意事项
- 极易导致栈溢出
- 计算复杂度极高
- 主要用于理论研究

## 递归模式选择指南

### 1. 问题特征分析

| 问题特征 | 推荐模式 | 示例 |
|---------|---------|------|
| 线性处理 | 线性递归/尾递归 | 链表操作、数组遍历 |
| 分治问题 | 二分递归 | 快速排序、二分搜索 |
| 多种选择 | 多路递归 | 回溯、组合生成 |
| 状态转换 | 相互递归 | 解析器、状态机 |
| 理论研究 | 嵌套递归 | 数学函数 |

### 2. 性能考虑

```php
// 性能对比示例
class RecursionPerformance {
    // 线性递归 - O(n) 时间，O(n) 空间
    public static function sumLinear($n) {
        if ($n <= 0) return 0;
        return $n + self::sumLinear($n - 1);
    }
    
    // 尾递归 - O(n) 时间，理论上 O(1) 空间
    public static function sumTail($n, $acc = 0) {
        if ($n <= 0) return $acc;
        return self::sumTail($n - 1, $acc + $n);
    }
    
    // 二分递归 - O(2^n) 时间（未优化）
    public static function fibBinary($n) {
        if ($n <= 1) return $n;
        return self::fibBinary($n - 1) + self::fibBinary($n - 2);
    }
    
    // 优化的二分递归 - O(n) 时间
    public static function fibMemo($n, &$memo = []) {
        if (isset($memo[$n])) return $memo[$n];
        if ($n <= 1) return $n;
        $memo[$n] = self::fibMemo($n - 1, $memo) + 
                    self::fibMemo($n - 2, $memo);
        return $memo[$n];
    }
}
```

### 3. 转换技巧

#### 线性递归转循环
```php
// 递归版本
function factorialRec($n) {
    if ($n <= 1) return 1;
    return $n * factorialRec($n - 1);
}

// 循环版本
function factorialLoop($n) {
    $result = 1;
    for ($i = 2; $i <= $n; $i++) {
        $result *= $i;
    }
    return $result;
}
```

#### 优化多路递归
```php
// 使用剪枝减少递归调用
function nQueensPruned($n, $row = 0, $cols = [], $diag1 = [], $diag2 = []) {
    if ($row === $n) return 1;
    
    $count = 0;
    for ($col = 0; $col < $n; $col++) {
        if (in_array($col, $cols) || 
            in_array($row - $col, $diag1) || 
            in_array($row + $col, $diag2)) {
            continue; // 剪枝
        }
        
        $cols[] = $col;
        $diag1[] = $row - $col;
        $diag2[] = $row + $col;
        
        $count += nQueensPruned($n, $row + 1, $cols, $diag1, $diag2);
        
        array_pop($cols);
        array_pop($diag1);
        array_pop($diag2);
    }
    
    return $count;
}
```

## 小结

1. **线性递归**：最基础，适合简单的序列处理
2. **尾递归**：可优化为循环，适合累积计算
3. **二分递归**：适合分治，注意避免重复计算
4. **多路递归**：适合搜索和组合，使用剪枝优化
5. **相互递归**：适合状态机和解析器
6. **嵌套递归**：极少使用，主要用于理论研究

选择合适的递归模式可以让代码更清晰、更高效。理解每种模式的特点和适用场景，是掌握递归的关键。

## 思考题

1. 为什么尾递归理论上可以优化成循环？
2. 如何判断一个递归问题适合用哪种模式？
3. 记忆化对所有递归模式都有效吗？为什么？

## 下一步

掌握了各种递归模式后，下一章我们将学习[递归优化技巧](04_递归优化技巧.md)，深入探讨如何提高递归算法的性能。
